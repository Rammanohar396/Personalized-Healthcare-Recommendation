# -*- coding: utf-8 -*-
"""Personalized Healthcare Recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fqux2JvvNZlrnrRTwvGYBoVD_7ofYX8f
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix, classification_report
from imblearn.over_sampling import SMOTE
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/blood.csv')

df.head()

df.info( )

df.shape

df.describe()

df.isnull().sum()

df.dropna(inplace=True)

df.duplicated().sum()

df.index

print(df["Class"].value_counts(normalize=True) * 100)

plt.figure(figsize=(5, 4))
sns.countplot(x="Class", data=df, palette="Set2")
plt.title("Class Distribution (0 = Not Donated, 1 = Donated)")
plt.xlabel("Class")
plt.ylabel("Count")
plt.show()

sns.pairplot(df, hue="Class", palette="husl")
plt.suptitle("Pairwise Feature Relationships", y=1.02)
plt.show()

plt.figure(figsize=(8, 6))
sns.heatmap(df.corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Feature Correlation Heatmap")
plt.show()

X = df.drop("Class", axis=1)
y = df["Class"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

sm = SMOTE(random_state=42)
X_train_bal, y_train_bal = sm.fit_resample(X_train_scaled, y_train)

model = RandomForestClassifier(random_state=42)
model.fit(X_train_bal, y_train_bal)

y_pred = model.predict(X_test_scaled)
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

importances = pd.Series(model.feature_importances_, index=X.columns)
plt.figure(figsize=(6, 4))
importances.sort_values().plot(kind='barh', color='skyblue')
plt.title("Feature Importance")
plt.xlabel("Importance Score")
plt.show()

def generate_recommendation(input_df):
    input_scaled = scaler.transform(input_df)
    prediction = model.predict(input_scaled)[0]
    recommendation_map = {
        0: "No immediate action needed.",
        1: "Recommend regular blood donation and health check-up."
    }
    return recommendation_map[prediction]

"""#Example

"""

example = pd.DataFrame({
    "Recency": [4],
    "Frequency": [10],
    "Monetary": [2500],
    "Time": [30]
})
recommendation = generate_recommendation(example)
print("\n Recommendation for example input:", recommendation)

!pip install streamlit

# Streamlit app for Personalized Healthcare Recommendations
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split

# Load and preprocess dataset
df = pd.read_csv("blood.csv")
X = df.drop("Class", axis=1)
y = df["Class"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

smote = SMOTE(random_state=42)
X_train_res, y_train_res = smote.fit_resample(X_train_scaled, y_train)

model = RandomForestClassifier(random_state=42)
model.fit(X_train_res, y_train_res)

# Streamlit UI
st.title("🏥 Personalized Healthcare Recommendation System")
st.markdown("Enter your details to receive a health recommendation based on blood donation history.")

recency = st.slider("Months since last donation (Recency)", 0, 74, 12)
frequency = st.slider("Number of times donated (Frequency)", 1, 50, 5)
monetary = st.slider("Total blood donated in c.c. (Monetary)", 250, 12500, 1000, step=250)
time = st.slider("Months since first donation (Time)", 2, 98, 24)

if st.button("Get Recommendation"):
    input_data = pd.DataFrame({
        "Recency": [recency],
        "Frequency": [frequency],
        "Monetary": [monetary],
        "Time": [time]
    })

    input_scaled = scaler.transform(input_data)
    prediction = model.predict(input_scaled)[0]

    result = "😐 No immediate action needed." if prediction == 0 else "🚗 Recommend regular blood donation and health check-up."

    st.success(result)

st.markdown("---")
st.markdown("**Note:** This model is for educational purposes and based on a simplified dataset. Always consult healthcare professionals for medical decisions.")

!pip install streamlit pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# from sklearn.preprocessing import StandardScaler
# from sklearn.ensemble import RandomForestClassifier
# 
# # Dummy model (or load yours)
# scaler = StandardScaler()
# model = RandomForestClassifier()
# 
# st.title("🩺 Personalized Healthcare Recommender")
# 
# recency = st.slider("Recency (months)", 0, 74, 10)
# frequency = st.slider("Frequency", 1, 50, 5)
# monetary = st.slider("Monetary (c.c.)", 250, 12500, 1000)
# time = st.slider("Time (months)", 2, 98, 24)
# 
# if st.button("Get Recommendation"):
#     # Normally you'd scale and predict here
#     pred = 1 if frequency > 5 else 0
#     result = "✅ Recommend regular donation and check-up" if pred == 1 else "🛑 No immediate action needed"
#     st.success(result)
#

from pyngrok import ngrok
import subprocess
import os
from threading import Timer

# Run Streamlit app in background
# Use absolute path for streamlit executable
streamlit_path = os.path.join(os.path.dirname(subprocess.run(['which', 'streamlit'], capture_output=True, text=True).stdout.strip()), 'streamlit')
subprocess.Popen([streamlit_path, 'run', 'app.py', '--server.port', '8501'])

# Get public URL
# Open a ngrok tunnel to the streamlit port
print("Opening ngrok tunnel to port 8501...")
public_url = ngrok.connect(8501).public_url
agent:
  authtoken: 30OwsMT3MKpwMaVFShtlLrdEl9E_6UNzS5Tpw83fBsG7yvf1G

print(f"🔗 Click here to access your app: {public_url}")